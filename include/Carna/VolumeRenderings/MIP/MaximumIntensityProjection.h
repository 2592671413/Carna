/*
 *  Copyright (C) 2010 - 2014 Leonid Kostrykin
 *
 *  Chair of Medical Engineering (mediTEC)
 *  RWTH Aachen University
 *  Pauwelsstr. 20
 *  52074 Aachen
 *  Germany
 *
 */

#ifndef MIP_MAXIMUMINTENSITYPROJECTION_H_6014714286
#define MIP_MAXIMUMINTENSITYPROJECTION_H_6014714286

/** \file   MaximumIntensityProjection.h
  * \brief  Defines \ref Carna::VolumeRenderings::MIP::MaximumIntensityProjection.
  */

#include <Carna/VolumeRenderings/VolumeRendererMode.h>
#include <deque>
#include <functional>

namespace Carna
{

namespace VolumeRenderings
{

/** \brief  Provides classes related to the \ref VolumeRenderer "volume renderer"
  *         maximum intensity projection mode.
  *
  * You might be looking for the
  * \ref MIP::MaximumIntensityProjection "VolumeRendererMode MIP implementation".
  */
namespace MIP
{



// ----------------------------------------------------------------------------------
// VolumeRenderings :: MIP :: MaximumIntensityProjection
// ----------------------------------------------------------------------------------

/** \brief  \ref VolumeRendererMode implementation that provides a maximum intensity projection.
  *
  * \image html MaximumIntensityProjection01.jpg "Example maximum intensity projection rendering"
  *
  * \section MIP_Usage Usage
  *
  * The utilization of maximum intensity projections is as simple as obtaining an object from
  * <code>%MaximumIntensityProjection</code> class and installing it on a
  * \ref VolumeVisualization "volume visualization":
  *
  * \code
  * using namespace Carna::VolumeRenderings;
  * using namespace Carna::VolumeRenderings::MIP;
  *
  * VolumeVisualization* const visualization = new DefaultVolumeVisualization();
  * visualization->doAfterInitialization( [&]()
  *     {
  *         MaximumIntensityProjection* const mip = new MaximumIntensityProjection();
  *         visualization->renderer().installMode( mip );
  *
  *         // set the maximum intensity projection as the active visualization mode
  *         visualization->renderer().setMode( MaximumIntensityProjection::NAME );
  *     }
  * );
  * \endcode
  *
  * \see Refer to \ref VolumeRenderingExample for more complete examples.
  *
  * The <code>%MaximumIntensityProjection</code> class is capable of visualizing different HU
  * ranges in different colors. In order to achieve this, it associates each HU range with a
  * starting and an ending color. HU values in between are interpolated linearly. Each HU range
  * that is associated with such two colors is called a \em channel.
  *
  * \subsection MIP_Channels Channels
  *
  * \ref Channel "Channels" are allowed to be \ref addChannel "added", \ref removeChannel "removed" and
  * \ref visitChannels "modified" at any time, but not before the <code>%MaximumIntensityProjection</code>
  * object was installed on a renderer. There are a few things to know about channels that are best
  * explained with an example.
  *
  * Let there be the two channels \f$[-1024, 0]\to[\text{black}, \text{green}]\f$ and
  * \f$[1;3071]\to[\text{blue}, \text{red}]\f$. Futhermore, imagine the maximum intensity projection
  * was being rendered from such a perspective, that two voxels with the HU values \f$0\f$ and \f$3071\f$
  * were mapped to the same screen pixels. Since \f$3071\f$ represents a higher intensity than \f$0\f$,
  * usually one would expect the resulting pixel color to be \f$\text{red}\f$. However, there might be
  * use cases that do benefit from the information that \em both channels attain very high values
  * regarding their HU ranges respectively. The following two directives are made to enable this:
  *
  * - The channels are organized in an ordered list.
  * - Each channel is associated with a particular blending \em function from type \f$(\text{Color},\text{Color})\to\text{Color}\f$.
  *
  * The rule is: For each pixel, all channels are evaluated sequentially, starting with the lower
  * ordered channels. If the channel produces a pixel color, the \ref ChannelFunction "channel function"
  * is used to incorporate the produced pixel color with the pixel color that was generated by the
  * lower ordered channels. The resulting pixel color is again incorporated by the next higher ordered
  * channel and so on.
  *
  * There are two channel functions available out of the box: pixel colors generated by higher ordered
  * channels either \ref ChannelReplaceFunction "replace pixel colors" that are generated by lower
  * ordered channels, or they are \ref ChannelAddFunction "summed up". In the example above, if the
  * channels were set to additive, the resulting pixel color was\f$\text{green} + \text{red} = \text{yellow}\f$.
  *
  * \note
  * The <code>%MaximumIntensityProjection</code> class supports \ref ascendChannel "swapping"
  * neighboring channels as a direct operation.
  *
  * The moment the <code>%MaximumIntensityProjection</code> object is installed on a renderer, the
  * channels list is set to it's initial state: The channel
  * \f$( [-1024, 3071] \to [\mathrm{rgba}(1,1,1,0), \mathrm{rgba}(1,1,1,1)] )\f$ is the only channel
  * than. The pixels it produces are configured to replace any previously drawn pixels. However, this
  * is of no interest as long as no further channels are added.
  *
  * If all channels were removed from the list, nothing will be rendered. 
  *
  * \section MIP_Algorithm Algorithm
  *
  * The algorithm is based on \ref VolumeRendererRayMarching "ray marching": For each screen fragment
  * a ray is casted through the volume. For $n$ channels, the resulting pixel color $p_n$ is obtained
  * through sampling volume intensities along the ray \f$r \subset \mathbb{R}^3\f$. With the channel's
  * blending function \f$ f_i : (\text{Color}, \text{Color}) \to \text{Color}\f$ and it's color map
  * \f$c_i : [-1024, 3071] \to \text{Color}\f$ the resulting pixel color $p_n$ is defined through:
  *
  * \f[
  * p_i = \begin{cases}
  * 0 & \text{if } i = 0 \\
  * f_i\left( c_{i-1},\ c_i\left( \max\limits_{x \in X\left(r, c_i\right)}\ a\left(x\right) \right) \right) & \text{else.}
  * \end{cases}
  * \f]
  *
  * As stated in the section above, we are not interested in \f$\max\limits_{x \in r}\ a(x)\f$, where
  * \f$a : \mathbb{R}^3 \to \mathbb{R}\f$ is the volume data of interest. Instead, we are only looking
  * at those ray voxels that are mapped into the domain of the channel's color map \f$c_i\f$:
  *
  * \f[
  * X\left(r, c_i\right) = \left\{ x | x \in r \wedge \exists y \in \text{Color} : \left(a(x), y\right) \in c_i \right\}
  * \f]
  *
  * The blending function \f$ f_i \f$ is defined generally as
  *
  * \f[ f_i( c_\text{prev}, c_\text{new} ) = \gamma_\text{prev} c_\text{prev} + \gamma_\text{new} c_\text{new} \f]
  *
  * where \f$ \gamma_\text{prev}, \gamma_\text{new} \f$ are two weightening terms. For example,
  * the \em replacing blending function is defined through
  *
  * \f[
  * \gamma_\text{prev} = 1 - \alpha(c_\text{new})
  * \quad\text{and}\quad
  * \gamma_\text{new} = \alpha(c_\text{new})
  * \text{,}
  * \f]
  *
  * whereas the \em additive blending function uses
  *
  * \f[
  * \gamma_\text{prev} = 1
  * \quad\text{and}\quad
  * \gamma_\text{new} = \alpha(c_\text{new})
  * \text{.}
  * \f]
  *
  * The function \f$ \alpha : \text{Color} \to [0, 1] \f$ references the alpha component of a given color.
  *
  * \section MIP_Implementation Implementation
  *
  * The implementation consists of two steps:
  *
  * -#  For every channel \f$i\f$ a maximum intensity texture is rendered, that consists of only one 8bit
  *     floating point color channel, evaluating each pixel likes as follows, where \f$\mathbb{D}\f$
  *     denotes the domain of a function:
  *     \f[ \mathrm{ pixel } = \begin{cases}
  *         \left( \max\limits_{x \in X\left(r, c_i\right)}\ a(x) - \min\left(\mathbb{D} f_i\right) \right)
  *         \cdot\frac{1}{ \max\left(\mathbb{D} f_i\right) - \min\left(\mathbb{D} f_i\right) }
  *         & \text{if } X\left(r, c_i\right) \neq \emptyset \\
  *         0
  *         & \text{else.}
  *     \end{cases} \f]
  *     This is done by the \em MIP-shader, that is implemented in \em mip.frag.
  * -#  The per-channel maximum intensity textures are rendered one upon each other, using their
  *     corresponding blending functions and the \em mip-colorizer shader, that performs the color
  *     mapping. The shader is implemented in \em mip-colorizer.frag.
  *
  * Since the volume needs to be evaluated multiple times, the \c %MaximumIntensityProjection is not
  * derived from \ref VolumeRendererSinglePassMode. The alternative would be performing a multitude of
  * dynamic branches, which is told to be deadly slow on GPU.
  *
  * \author Leonid Kostrykin
  * \date   26.7.11 - 17.6.14
  */
class CARNA_EXPORT MaximumIntensityProjection : public VolumeRendererMode
{

    Q_OBJECT

public:

    // ------------------------------------------------------------------------------
    // Constructors & Destructors
    // ------------------------------------------------------------------------------

    /** \brief  Instantiates.
      */
    MaximumIntensityProjection();

    /** \brief  Does nothing.
      */
    virtual ~MaximumIntensityProjection();

    // ------------------------------------------------------------------------------
    // VolumeRendererMode Implementation
    // ------------------------------------------------------------------------------
    
    /** \brief  Holds the \ref VolumeRendererMode::name "human-readable name" of this volume rendering mode.
      */
    const static std::string NAME;

    virtual QWidget* createControllerUI() override;

    virtual void renderColor( RayMarching& ) override;

    /** \brief  Null-implementation of \ref VolumeRendererMode::renderDepth.
      */
    virtual void renderDepth( RayMarching& ) override;

    /** \brief  Acquires framebuffer object and an 'initial' channel.
      */
    virtual void prepareForRenderer( VolumeRenderer& ) override;

    /** \brief  Activates alpha blending.
      */
    virtual void start() override;

    /** \brief  Resizes the framebuffer object and all maximum intensity textures.
      */
    virtual void resizeBuffers( int w, int h ) override;

    // ------------------------------------------------------------------------------
    // Channel Management
    // ------------------------------------------------------------------------------

    /** \brief  Defines visitor interface to mutable \ref Channel objects.
      */
    typedef std::function< bool( Channel& ) > ChannelVisitor;
    
    /** \brief  Defines visitor interface to immutable \ref Channel objects.
      */
    typedef std::function< bool( const Channel& ) > ConstChannelVisitor;

    /** \brief  Accepts \a visitor and makes it visit all channels.
      */
    void visitChannels( ChannelVisitor& visitor );
    
    /** \brief  Accepts \a visitor and makes it visit all channels.
      */
    void visitChannels( ConstChannelVisitor& visitor ) const;


public slots:

    /** \brief  Swaps positions of \a channel with it's successor in the \ref MIP_Channels "channels list".
      *
      * \pre \a channel is in channels list
      * \pre \a channel has successor
      * \pre <code>isInitialized()</code>
      *
      * Also \ref invalidate "invalidates the renderer".
      */
    void ascendChannel( const Carna::VolumeRenderings::MIP::Channel& channnel );
    
    /** \brief  Appends \a channel to the \ref MIP_Channels "channels list" and takes it's ownership.
      *
      * \pre \a channel is not in channels list yet
      * \pre <code>isInitialized()</code>
      *
      * Also \ref invalidate "invalidates the renderer".
      */
    void addChannel( Carna::VolumeRenderings::MIP::Channel* channel );
    
    /** \brief  Removes \a channel from the \ref MIP_Channels "channels list".
      *
      * \warning
      * Does \em not delete the channel! The ownership of \a channel is handed to the caller.
      *
      * \pre \a channel is in channels list
      * \pre <code>isInitialized()</code>
      *
      * Also \ref invalidate "invalidates the renderer".
      */
    void removeChannel( Carna::VolumeRenderings::MIP::Channel& channel );


private:

    // ------------------------------------------------------------------------------
    // PIMPL
    // ------------------------------------------------------------------------------

    class Details;
    const std::unique_ptr< Details > pimpl;

}; // VolumeRenderings :: MIP :: MaximumIntensityProjection



}  // namespace Carna :: VolumeRenderings :: MIP

}  // namespace Carna :: VolumeRenderings

}  // namespace Carna

#endif // MIP_MAXIMUMINTENSITYPROJECTION_H_6014714286
