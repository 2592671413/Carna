<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Carna: Carna::VolumeRenderings::DVR::DirectVolumeRendering Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<link href="doc_00style.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Carna&#160;<span id="projectnumber">Version 2.5.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_carna.html">Carna</a>      </li>
      <li class="navelem"><a class="el" href="namespace_carna_1_1_volume_renderings.html">VolumeRenderings</a>      </li>
      <li class="navelem"><a class="el" href="namespace_carna_1_1_volume_renderings_1_1_d_v_r.html">DVR</a>      </li>
      <li class="navelem"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html">DirectVolumeRendering</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-slots">Public Slots</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Carna::VolumeRenderings::DVR::DirectVolumeRendering Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Carna::VolumeRenderings::DVR::DirectVolumeRendering" --><!-- doxytag: inherits="Carna::VolumeRenderings::VolumeRendererSinglePassMode" -->
<p><a class="el" href="class_carna_1_1_volume_renderings_1_1_volume_renderer_mode.html" title="Abstract base class for ray marching implementations.">VolumeRendererMode</a> implementation which simulates light absorption on the basis of a color map.  
 <a href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_direct_volume_rendering_8h_source.html">DirectVolumeRendering.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png"/> Inheritance diagram for Carna::VolumeRenderings::DVR::DirectVolumeRendering:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering__inherit__graph.png" border="0" usemap="#_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering_inherit__map" alt="Inheritance graph"/></div>
<map name="_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering_inherit__map" id="_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering_inherit__map">
<area shape="rect" id="node2" href="class_carna_1_1_volume_renderings_1_1_volume_renderer_single_pass_mode.html" title="Abstract implementation of VolumeRendererMode, suitable for all further implementations which do requ..." alt="" coords="5,80,379,107"/><area shape="rect" id="node4" href="class_carna_1_1_volume_renderings_1_1_volume_renderer_mode.html" title="Abstract base class for ray marching implementations." alt="" coords="37,5,347,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png"/> Collaboration diagram for Carna::VolumeRenderings::DVR::DirectVolumeRendering:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering__coll__graph.png" border="0" usemap="#_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering_coll__map" alt="Collaboration graph"/></div>
<map name="_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering_coll__map" id="_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering_coll__map">
<area shape="rect" id="node2" href="class_carna_1_1_volume_renderings_1_1_volume_renderer_single_pass_mode.html" title="Abstract implementation of VolumeRendererMode, suitable for all further implementations which do requ..." alt="" coords="5,432,379,459"/><area shape="rect" id="node4" href="class_carna_1_1_volume_renderings_1_1_volume_renderer_mode.html" title="Abstract base class for ray marching implementations." alt="" coords="37,355,347,381"/><area shape="rect" id="node6" href="class_carna_1_1_volume_renderings_1_1_volume_renderer.html" title="Abstract Renderer specialization that is supposed to utilize Ray Marching as it&#39;s rendering technique..." alt="" coords="53,264,331,291"/><area shape="rect" id="node8" href="class_carna_1_1base_1_1view_1_1_renderer.html" title="Represents the view component of a visualization and implements its rendering logic." alt="" coords="100,187,284,213"/><area shape="rect" id="node10" href="class_carna_1_1base_1_1view_1_1_scene_provider.html" title="Interfaces the data model from a view&#39;s perspective and provides graphical representations of model e..." alt="" coords="85,96,299,123"/><area shape="rect" id="node12" href="class_carna_1_1base_1_1model_1_1_scene.html" title="Defines the data model." alt="" coords="102,5,281,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-slots"></a>
Public Slots</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#ab5554085f4113af1ccbe77c19be38031">setPositionedObject</a> (<a class="el" href="class_carna_1_1base_1_1model_1_1_object3_d.html">Carna::base::model::Object3D</a> &amp;object)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>object</em> to be re-positioned.  <a href="#ab5554085f4113af1ccbe77c19be38031"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#ad09b9fec2d6a7822e5047ee189a4bd55">removePositionedObject</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets no <a class="el" href="class_carna_1_1base_1_1model_1_1_object3_d.html">base::model::Object3D</a> to be re-positioned.  <a href="#ad09b9fec2d6a7822e5047ee189a4bd55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a7dd0ea594a93e5fca6acb0e270555aae">setLightAmplitude</a> (double lightAmplitude)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the currently configured light amplitude to <em>lightAmplitude</em>.  <a href="#a7dd0ea594a93e5fca6acb0e270555aae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#adf84e8707976744a151af909d1d9ff7b">setLightBias</a> (double lightBias)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the currently configured light bias to <em>lightBias</em>.  <a href="#adf84e8707976744a151af909d1d9ff7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a0f37f1c99ee26e6d78eacad1ba49470e">setLighting</a> (bool lighting)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether lighting is enabled.  <a href="#a0f37f1c99ee26e6d78eacad1ba49470e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#af8381000ba14daeb5113db60a517373a">setLightBackFaceAmount</a> (double lightBackFaceAmount)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the currently configured light amount multiplier for back faces.  <a href="#af8381000ba14daeb5113db60a517373a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#ac49011f4baa47626a50c01df26c0af4d">setPickingSaturation</a> (double pickingSaturation)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the currently configured absorption threshold \(\theta \in [0,1]\) to light rays: when the ray intensity becomes <em>higher</em> than \(1 - \theta\), the ray is assumed to be absorbed completely. This is important for the 3D coordinates computation of clicked pixels in 2D space.  <a href="#ac49011f4baa47626a50c01df26c0af4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a81ba018cae27bd874db48d696426bf13">commitColorMap</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits color map changes immediately.  <a href="#a81ba018cae27bd874db48d696426bf13"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab58a9ef19cafd7da0d9dbcf5724efab7"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::DirectVolumeRendering" ref="ab58a9ef19cafd7da0d9dbcf5724efab7" args="(base::model::Scene &amp;model)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#ab58a9ef19cafd7da0d9dbcf5724efab7">DirectVolumeRendering</a> (<a class="el" href="class_carna_1_1base_1_1model_1_1_scene.html">base::model::Scene</a> &amp;model)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b387a222eae272e1496e27ef9d84d1b"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::~DirectVolumeRendering" ref="a5b387a222eae272e1496e27ef9d84d1b" args="()" -->
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a5b387a222eae272e1496e27ef9d84d1b">~DirectVolumeRendering</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the color map texture. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a534cae1c8abdc86b35302703d73ed8df">resizeBuffers</a> (int width, int height) override</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be invoked when associated renderer is resized. The <a class="el" href="class_carna_1_1_volume_renderings_1_1_volume_renderer.html">VolumeRenderer</a> implementations does so.  <a href="#a534cae1c8abdc86b35302703d73ed8df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6421f74015b27e81cfd989ead75bcea3"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::prepareForRenderer" ref="a6421f74015b27e81cfd989ead75bcea3" args="(VolumeRenderer &amp;) override" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a6421f74015b27e81cfd989ead75bcea3">prepareForRenderer</a> (<a class="el" href="class_carna_1_1_volume_renderings_1_1_volume_renderer.html">VolumeRenderer</a> &amp;) override</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires color map texture. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfa3abaa765ffa8aa30e633e5886dfe2"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::start" ref="abfa3abaa765ffa8aa30e633e5886dfe2" args="() override" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#abfa3abaa765ffa8aa30e633e5886dfe2">start</a> () override</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds color map texture and starts color map rebuild timer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f922ebeab27e6b9baa5f94ce1ab898c"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::stop" ref="a4f922ebeab27e6b9baa5f94ce1ab898c" args="() override" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a4f922ebeab27e6b9baa5f94ce1ab898c">stop</a> () override</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Halts color map rebuild timer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a505ece4cff39fc4fb8a6ced9371d5d8a"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::renderColor" ref="a505ece4cff39fc4fb8a6ced9371d5d8a" args="(RayMarching &amp;) override" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a505ece4cff39fc4fb8a6ced9371d5d8a">renderColor</a> (<a class="el" href="class_carna_1_1_volume_renderings_1_1_ray_marching.html">RayMarching</a> &amp;) override</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the rendering. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#adaa690891bb681c6262ed7b039406d5d">renderDepth</a> (<a class="el" href="class_carna_1_1_volume_renderings_1_1_ray_marching.html">RayMarching</a> &amp;) override</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing.  <a href="#adaa690891bb681c6262ed7b039406d5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3635fcab52bdd5430e472ff44f7bb7a4"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::createControllerUI" ref="a3635fcab52bdd5430e472ff44f7bb7a4" args="() override" -->
virtual QWidget *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a3635fcab52bdd5430e472ff44f7bb7a4">createControllerUI</a> () override</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates and returns this mode's controller UI element or <code>nullptr</code> if it has none. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e45d81de275d63ce9932c1a26db5fe2"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::hasPositionedObject" ref="a4e45d81de275d63ce9932c1a26db5fe2" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a4e45d81de275d63ce9932c1a26db5fe2">hasPositionedObject</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether an <a class="el" href="class_carna_1_1base_1_1model_1_1_object3_d.html">base::model::Object3D</a> is selected to be re-positioned. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_carna_1_1base_1_1model_1_1_object3_d.html">base::model::Object3D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a61c0d6e0a7346ab73d7012118d57fc88">getPositionedObject</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">References the <a class="el" href="class_carna_1_1base_1_1model_1_1_object3_d.html">base::model::Object3D</a> to be re-positioned.  <a href="#a61c0d6e0a7346ab73d7012118d57fc88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad97cee41099ab8a096a78ca9e6cc2c7"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::getLightAmplitude" ref="aad97cee41099ab8a096a78ca9e6cc2c7" args="() const " -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#aad97cee41099ab8a096a78ca9e6cc2c7">getLightAmplitude</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the currently configured light amplitude. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae18b9606d4a30e304478f1700907045"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::getLightBias" ref="aae18b9606d4a30e304478f1700907045" args="() const " -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#aae18b9606d4a30e304478f1700907045">getLightBias</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the currently configured light bias. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65e1c3dd682237b32e8cc95aaa7faf3e"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::hasLighting" ref="a65e1c3dd682237b32e8cc95aaa7faf3e" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a65e1c3dd682237b32e8cc95aaa7faf3e">hasLighting</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether lighting is enabled. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fecdf8805f843c997aace6a156ca4dd"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::getLightBackFaceAmount" ref="a5fecdf8805f843c997aace6a156ca4dd" args="() const " -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a5fecdf8805f843c997aace6a156ca4dd">getLightBackFaceAmount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the currently configured light amount multiplier for back faces. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec0ab43ad48e53cabd1250cfd3f9c2d2"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::getPickingSaturation" ref="aec0ab43ad48e53cabd1250cfd3f9c2d2" args="() const " -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#aec0ab43ad48e53cabd1250cfd3f9c2d2">getPickingSaturation</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the currently configured absorption threshold \(\theta \in [0,1]\) to light rays: when the ray intensity becomes <em>higher</em> than \(1 - \theta\), the ray is assumed to be absorbed completely. This is important for the 3D coordinates computation of clicked pixels in 2D space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdfa32bfdffe4b6da748b38267bbac02"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::mutableModel" ref="abdfa32bfdffe4b6da748b38267bbac02" args="()" -->
<a class="el" href="class_carna_1_1base_1_1model_1_1_scene.html">base::model::Scene</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#abdfa32bfdffe4b6da748b38267bbac02">mutableModel</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">References the mutable data model. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fbfa1d5250b55007c14978bb3acb5c7"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::colorMap" ref="a8fbfa1d5250b55007c14978bb3acb5c7" args="()" -->
<a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_color_map.html">ColorMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a8fbfa1d5250b55007c14978bb3acb5c7">colorMap</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">References the mutable color map. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f666946d68c117ebe0762ea77241caf"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::colorMap" ref="a4f666946d68c117ebe0762ea77241caf" args="() const " -->
const <a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_color_map.html">ColorMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a4f666946d68c117ebe0762ea77241caf">colorMap</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">References the color map. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a776265a5d4b0bf32bb5e9ee287e2e1ad"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::NAME" ref="a776265a5d4b0bf32bb5e9ee287e2e1ad" args="" -->
static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a776265a5d4b0bf32bb5e9ee287e2e1ad">NAME</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the <a class="el" href="class_carna_1_1_volume_renderings_1_1_volume_renderer_mode.html#abe8917af30fb3578be2d38be49f9ca35">human-readable name</a> of this volume rendering mode. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4415828cdff28ce6948b1454be03581b"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::configureShader" ref="a4415828cdff28ce6948b1454be03581b" args="(RayMarching &amp;, base::view::ShaderProgram::Binding &amp;) override" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a4415828cdff28ce6948b1454be03581b">configureShader</a> (<a class="el" href="class_carna_1_1_volume_renderings_1_1_ray_marching.html">RayMarching</a> &amp;, <a class="el" href="class_carna_1_1base_1_1view_1_1_shader_program_1_1_binding.html">base::view::ShaderProgram::Binding</a> &amp;) override</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Supplies custom arguments to the shader. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_carna_1_1_volume_renderings_1_1_volume_renderer_mode.html" title="Abstract base class for ray marching implementations.">VolumeRendererMode</a> implementation which simulates light absorption on the basis of a color map. </p>
<div class="image">
<img src="AbsorptionProjection01.png" alt="AbsorptionProjection01.png"/>
</div>
<h2><a class="anchor" id="DVR_Algorithm"></a>
Algorithm</h2>
<p>For each pixel the <a class="el" href="class_carna_1_1_volume_renderings_1_1_default_volume_renderer.html#VolumeRendererRayMarching">ray marching algorithm</a> samples voxels along a casted ray in equidistant steps. The DVR computes the sum of the \( w_i \) weighted colors \( \vec f_{\mathrm{rgb}} \), that are obtained by mapping voxel intensities at some position \( \vec x_i \) along the ray:</p>
<p class="formulaDsp">
\[ \vec v_\text{pixel color} = \sum\limits_{i=1}^s w_i \cdot \vec f_{\mathrm{rgb}}( \vec x_i ) \quad \text{with} \quad \text{sample rate } s := \frac{\text{samples}}{\text{pixel}} \]
</p>
<p>The weights \( w_i \) consist of two factors. The first factor, the <em>scaled alpha</em>, controls the contribution of a voxel intensity to the final pixel color, based on the alpha value that is mapped to a voxel intensity:</p>
<p class="formulaDsp">
\[ a_i = 1 - \Big( 1 - f_{\alpha}\left( \vec x_i \right) \Big)^{ \frac{ s_0 }{ s } } \]
</p>
<p>In this equation, \( s_0 \) is the <em>reference sampling rate</em>. It is required to produce similar results across different sampling rates \( s \). This DVR implementation uses \( s_0 = 256 \), for it has proven to produce satisfying results.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>The original equation can be found in <a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch39.html#ch39equ03">''NVIDIA GPU Gems 3'', chapter 39.4.3, ''Rendering''</a>. It is denoted as Equation 3, ''Formula for Opacity Correction''.</dd></dl>
<p>The second factor controls the contribution of the \( i \)th sample based on the <em>opacity</em> of the voxels that were sampled before:</p>
<p class="formulaDsp">
\[ o_{i} = \begin{cases} 1 &amp; \text{ if } i = 1 \\ o_{i-1} \cdot \left( 1 - a_i \right) &amp; \text{ else} \end{cases} \]
</p>
<p>For each ray the color weights \( w_i = a_i \cdot o_i \) are a monotonously decreasing sequence. The higher the alpha value \( f_{\mathrm\alpha}( \vec x_i ) \) is, the greater the difference \( w_i - w_{i+1} \) becomes.</p>
<h2><a class="anchor" id="DVR_Usage"></a>
Usage</h2>
<p>The code below shows how the class is supposed to be used with a <a class="el" href="class_carna_1_1_volume_renderings_1_1_volume_visualization.html">VolumeVisualization</a> module. The DVR is installed on the given <code>VolumeVisualization</code> and activated immediately:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> <span class="keywordtype">void</span> doDVR
         ( <a class="code" href="class_carna_1_1_volume_renderings_1_1_volume_visualization.html" title="Abstract implementation of the Visualization class that is supposed to perform volume rendering using...">Carna::VolumeRenderings::VolumeVisualization</a>&amp; module
         , <a class="code" href="class_carna_1_1base_1_1model_1_1_scene.html" title="Defines the data model.">Carna::base::model::Scene</a>&amp; scene )
 {
     module.<a class="code" href="class_carna_1_1base_1_1_visualization.html#a158f4074d4c8abf763ada287b4de27bc" title="Invokes the given function as soon as it is legal to access the renderer.">doAfterInitialization</a>( [&amp;]()
     {
         <span class="keyword">auto</span> <span class="keyword">const</span> dvr = <span class="keyword">new</span> <a class="code" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#ab58a9ef19cafd7da0d9dbcf5724efab7" title="Instantiates.">Carna::VolumeRenderings::DVR::DirectVolumeRendering</a>( scene );
         module.<a class="code" href="class_carna_1_1_volume_renderings_1_1_volume_visualization.html#aa80f4d46bdb0287ab01125944aed6d63" title="References the mutable composed renderer.">renderer</a>().installMode( dvr );
         module.<a class="code" href="class_carna_1_1_volume_renderings_1_1_volume_visualization.html#aa80f4d46bdb0287ab01125944aed6d63" title="References the mutable composed renderer.">renderer</a>().setMode( <a class="code" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a776265a5d4b0bf32bb5e9ee287e2e1ad" title="Holds the human-readable name of this volume rendering mode.">Carna::VolumeRenderings::DVR::DirectVolumeRendering::NAME</a> );
     }
 }
</pre></div><p>When you use this code snippet, you might end up with an empty rendering result. This will be the case when you use the code above for rendering <em>once</em>, e.g. to an <a class="el" href="class_carna_1_1base_1_1_offscreen_display.html">OffscreenDisplay</a>. The next section explains why this might happen and how to handle this case properly.</p>
<h3><a class="anchor" id="DVR_ColorMap"></a>
Color map</h3>
<p>The color map is an one-to-one relation \( \vec \varphi : D_{\vec\varphi} \to \text{Color} \) with \( D_{\vec\varphi} \subseteq [-1024; 3071] \). The function \( \vec f \), that was used in the section above to denote the color mapped to a voxel by it's intensity, therefore is simply:</p>
<p class="formulaDsp">
\[ \vec f\left( \vec x \right) = \vec\varphi\left( \mathrm{intensity}\left( \vec x \right) \right) \]
</p>
<p>When <code>DirectVolumeRendering</code> is instantiated, it computes an initial color map automatically. This is done by analyzing the histogram of the loaded data set.</p>
<dl class="user"><dt><b>Color lookup texture</b></dt><dd></dd></dl>
<p>The <a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a8fbfa1d5250b55007c14978bb3acb5c7">color map</a> consists of distinct <a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_color_map.html#aeaefcfec094a3dd206b0ec4dfc1ba708">HU ranges</a>, that are mapped to arbitrary <a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_color_map.html#aa996ca9b44b6253e02229f191a1c024d">color ranges</a>. Both range types are specified through their boundary values. Linear interpolation is used to determine the values in between. Since performing linear interpolation for each color lookup is an expansive and redundant operation, a single <em>color lookup texture</em> \( \vec\tau : [-1024; 3071] \to \text{Color} \) is built before the rendering. This color lookup texture \( \vec\tau \) also is a one-to-one relation:</p>
<p class="formulaDsp">
\[ \vec\tau\left( h \right) = \begin{cases} \vec\varphi\left( h \right) &amp; \forall h \in D_{\vec\varphi} \\ \left( 0, 0, 0, 0 \right)^{\mathrm T} &amp; \forall h \not\in D_{\vec\varphi} \end{cases} \]
</p>
<p>Hence, HU values, that are not mapped by the color map explicitly, are now mapped by \( \vec\tau \) to zero-alpha colors.</p>
<dl class="user"><dt><b>Asynchronous updating</b></dt><dd></dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>The color lookup texture isn't rebuilt every time the <a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_color_map.html#aef636229908d32f7d7fad97685ca4441">color map changes</a>. Instead, it is just guaranteed that it is rebuilt <em>within a short time period</em>. This is done to avoid unnecessary computations when the color map changes frequently, e.g. because of user interaction.</dd></dl>
<p>Since the DVR <a class="el" href="class_carna_1_1base_1_1view_1_1_renderer.html#a1e3413ebb2e158fa8b39c33bf2df06c3">invalidates the renderer</a> as soon as a new color lookup texture has been built, the user shouldn't notice any delay.</p>
<p>However, when you try to tap the result programmatically as soon as rendering is finished, there is high probability for you to encounter unexpected results. This is especially the case when rendering is invoked right after the <code>DirectVolumeRendering</code> class was instantiated. In this case, and whenever you need the color lookup texture to be rebuilt immediately, call <a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a81ba018cae27bd874db48d696426bf13">commitColorMap</a> before invoking the rendering:</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> <span class="keywordtype">void</span> immediatelyDoDVR
         ( <a class="code" href="class_carna_1_1_volume_renderings_1_1_volume_visualization.html" title="Abstract implementation of the Visualization class that is supposed to perform volume rendering using...">Carna::VolumeRenderings::VolumeVisualization</a>&amp; module
         , <a class="code" href="class_carna_1_1base_1_1model_1_1_scene.html" title="Defines the data model.">Carna::base::model::Scene</a>&amp; scene )
 {
     doDVR( module, scene );
     module.<a class="code" href="class_carna_1_1base_1_1_visualization.html#a158f4074d4c8abf763ada287b4de27bc" title="Invokes the given function as soon as it is legal to access the renderer.">doAfterInitialization</a>( [&amp;]()
     {
         <span class="keyword">typedef</span> <a class="code" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html" title="VolumeRendererMode implementation which simulates light absorption on the basis of a color map...">Carna::VolumeRenderings::DVR::DirectVolumeRendering</a> DVR;
         <span class="keyword">const</span> DVR&amp; dvr = <span class="keyword">static_cast&lt;</span> DVR <span class="keyword">&gt;</span>( module.<a class="code" href="class_carna_1_1_volume_renderings_1_1_volume_visualization.html#aa80f4d46bdb0287ab01125944aed6d63" title="References the mutable composed renderer.">renderer</a>().mode() );
         dvr.<a class="code" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a81ba018cae27bd874db48d696426bf13" title="Commits color map changes immediately.">commitColorMap</a>();
     }
 }
</pre></div><h2><a class="anchor" id="DVR_Implementation"></a>
Implementation</h2>
<p>As described <a class="el" href="class_carna_1_1_volume_renderings_1_1_default_volume_renderer.html#VolumeRendererRayMarching">here</a>, the ray marching algorithm computes a ray in volume space for each screen space pixel. This computation is implemented in the fragment shader. In order to make it execute for each screen pixel, a rectangle needs to be drawn over the whole screen.</p>
<h3><a class="anchor" id="DVR_VertexShader"></a>
Vertex shader</h3>
<p>The corresponding vertex shader transforms this rectangle's vertices through the fixed functionality pipeline. The <a class="el" href="class_carna_1_1base_1_1view_1_1_renderer.html#a2d2b38a8d4df5678e7f00d370bf97e32">base::view::Renderer::paintRectangle</a> method, that is used to draw the rectangle, denotes the vertices with corresponding texture coordinates. Those coordinates are passed to the fragment shader.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #version 120</span>
<span class="preprocessor"></span> 
 <span class="keywordtype">void</span> main()
 {
     gl_Position = ftransform();
     gl_TexCoord[ 0 ] = gl_MultiTexCoord0;
 }
</pre></div><h3><a class="anchor" id="DVR_FragmentShader"></a>
Fragment shader</h3>
<p>The fragment shader is the part where the fun happens. First, we have the declarations of all the uniforms <em>every</em> volume rendering mode shader must accept. These variables are determined by the <a class="el" href="class_carna_1_1_volume_renderings_1_1_ray_marching.html">ray marching configuration object</a>, that is passed in to <a class="el" href="class_carna_1_1_volume_renderings_1_1_volume_renderer_single_pass_mode.html#aaeca80bd123246f5f4dc1c2f1fbb9c13">VolumeRendererSinglePassMode::renderColor</a> from the renderer. The base class <a class="el" href="class_carna_1_1_volume_renderings_1_1_volume_renderer_single_pass_mode.html">VolumeRendererSinglePassMode</a> uploads these variables to the shader.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #version 120</span>
<span class="preprocessor"></span> 
 uniform sampler3D intensityTexture;
 uniform sampler1D <a class="code" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a8fbfa1d5250b55007c14978bb3acb5c7" title="References the mutable color map.">colorMap</a>;
 uniform sampler2D frontFacesTexture;
 uniform sampler2D backFacesTexture;

 uniform <span class="keywordtype">int</span> sample_count;
</pre></div><p>These uniform variables are completed by those that are specific to this <code>VolumeRendererMode</code> implementation. They are set from within the <a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a4415828cdff28ce6948b1454be03581b">configureShader</a> implementation of the base class.</p>
<div class="fragment"><pre class="fragment"> uniform <span class="keywordtype">float</span> specular_amplitude;
 uniform <span class="keywordtype">float</span> specular_bias;
 uniform <span class="keywordtype">float</span> specular_back;
 uniform vec3 gradient_sample_distance;
 uniform <span class="keywordtype">float</span> pickingSaturation;
</pre></div><p>We will discuss the purpose of these variables later when they come into use.</p>
<dl class="user"><dt><b>Helper functions</b></dt><dd></dd></dl>
<p>The fragment shader defines the following helper functions, that are mostly self-explanatory.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> min( <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y )
 {
     <span class="keywordflow">return</span> x &lt; y ? x : y;
 }

 <span class="keywordtype">float</span> getIntensityAt( in vec3 a )
 {
     <span class="keywordflow">return</span> texture3D( intensityTexture, a ).r;
 }

 vec4 getSampleAt( in vec3 a )
 {
     <span class="keywordtype">float</span> i = getIntensityAt( a );
     <span class="keywordflow">return</span> texture1D( colorMap, i );
 }
</pre></div><p>The latter two functions implement the entities that were explained in the <a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#DVR_Algorithm">algorithm section</a>:</p>
<ul>
<li><code>getIntensityAt</code> implements \( \mathrm{intensity}\left( \vec x \right) \).</li>
<li><code>getSampleAt</code> implements the color mapping as defined by \( \vec f\left( \vec x \right) \) by sampling the color lookup texture:</li>
</ul>
<div class="image">
<img src="AbsorptionProjection02.png" alt="AbsorptionProjection02.png"/>
</div>
<p>The next two functions are required for the specular lighting implementation. <code>getGradient</code> computes and returns the gradient of the 3D volume at a certain point:</p>
<div class="fragment"><pre class="fragment"> vec3 getGradient( in vec3 a )
 {
     vec3 dx = vec3( 1, 0, 0 ) * gradient_sample_distance.x;
     vec3 dy = vec3( 0, 1, 0 ) * gradient_sample_distance.y;
     vec3 dz = vec3( 0, 0, 1 ) * gradient_sample_distance.z;
 
     vec3 gradient;
 
     gradient.x = ( getIntensityAt( a + dx ) - getIntensityAt( a - dx ) ) / ( 2 * dx.x );
     gradient.y = ( getIntensityAt( a + dy ) - getIntensityAt( a - dy ) ) / ( 2 * dy.y );
     gradient.z = ( getIntensityAt( a + dz ) - getIntensityAt( a - dz ) ) / ( 2 * dz.z );
 
     <span class="keywordflow">return</span> gradient;
 }
</pre></div><p>The result is than used by <code>getSpecularAmount</code> for the computation of the brightness shift. The function uses the gradient computed by <code>getGradient</code> as the surface normal and computes the dot product between this normal and the given light direction. This dot product is proportional to the angle between both vectors.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">float</span> getSpecularAmount( in vec3 a, vec3 light_direction )
 {
     <span class="keywordflow">if</span>( specular_amplitude == 0.0 )
     {
         <span class="keywordflow">return</span> 0;
     }
 
     vec3 surface_normal = normalize( getGradient( a ) );
 
     <span class="keywordtype">float</span> dot_result = dot( light_direction, surface_normal );
     <span class="keywordtype">float</span> f0 = max( 0.0, dot_result ) + specular_back * max( 0.0, -dot_result );
     <span class="keywordflow">return</span> specular_amplitude * ( f0 - specular_bias );
 }
</pre></div><p>The fragment shader is executed once for every pixel of the screen. It's main procedure first checks, whether the ray from the viewer's eye does intersect the volume at all.</p>
<p>The <code>frontFacesTexture</code> already contains the ray's first volume intersection point's texture space coordinates at any given screen space point. The screen space point is held by <code>gl_TexCoord[ 0 ].st</code>. Analogically, the <code>backFacesTexture</code> holds the ray's <em>second</em> volume intersection point.</p>
<p>Both of these textures are in RGBA format. It's RGB components carry the texture space coordinates. The alpha component indicates whether the RGB components are trust worthy (alpha value is <code>1</code>, otherwise <code>0</code>), meaning, whether there are intersection points at all.</p>
<p>The ray marching is not performed (early exit via <code>discard</code>) when the ray does not intersect the volume at two <em>different</em> locations.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> main()
 {
     vec4 front_texture_sample = texture2D( frontFacesTexture, gl_TexCoord[ 0 ].st );
     vec4 back_texture_sample = texture2D( backFacesTexture, gl_TexCoord[ 0 ].st );
 
     vec3 ray_volume_entry_point = front_texture_sample.xyz;
     vec3 ray_volume_exit_point = back_texture_sample.xyz;
 
     <span class="keywordflow">if</span>( front_texture_sample.a &lt; 0.01
      || back_texture_sample.a &lt; 0.01
      || distance( ray_volume_entry_point, ray_volume_exit_point ) &lt; 0.01 )
     {
         discard;
     }
</pre></div><p>Next, the ray marching parameters are computed:</p>
<div class="fragment"><pre class="fragment">     vec3 ray_direction = normalize( ray_volume_exit_point - ray_volume_entry_point );
     <span class="keywordtype">float</span> path_step_length = sqrt( 3.0 ) / ( sample_count - 1 );
     vec3 path_step = ray_direction * path_step_length;

     <span class="keywordtype">int</span> max_sample_count = int( distance( ray_volume_entry_point, ray_volume_exit_point )
                               / path_step_length );
     <span class="keywordtype">int</span> real_sample_count = min( sample_count, max_sample_count );
</pre></div><p>The ray marching algorithm samples voxels along a casted ray (from <code>ray_volume_entry_point</code> in <code>ray_direction</code>) in equidistant steps (<code>path_step</code>). The <a class="el" href="namespace_carna_1_1_volume_renderings_1_1_d_v_r.html" title="Additional VolumeRenderings sub-module, that implements the CT volume visualization as an evaluation ...">DVR</a> computes the sum of the \( a_i \) weighted colors \( \vec f \) mapped to the intensities of those voxels at some ray position \( x_i \) along the ray:</p>
<p class="formulaDsp">
\[ \vec v_\text{final color} = \sum\limits_{i=0}^{n - 1} a_i \cdot \vec f( \vec x_i ) \quad \text{with} \quad n := \text{sample count} \]
</p>
<p>Those colors \( \vec f( \vec x_i ) \) are obtained via <code>getSampleAt</code>, the weights are a monotonously decreasing sequence: The higher the alpha value \( f( x_i )_4 \) is, the greater the difference \( a_i - a_{i+1} \) becomes. The concrete calculation specification for \(a_i\) is token from: <a href="http://http.developer.nvidia.com/GPUGems/gpugems_ch39.html#ch39equ03">http://http.developer.nvidia.com/GPUGems/gpugems_ch39.html#ch39equ03</a></p>
<p>The initial value is chosen to be \(a_0=1\):</p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">float</span> opacity = 1.0;
</pre></div><p>And then the ray marching is performed / the sum computed:</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; real_sample_count; ++i )
     {
         vec3 x_i = ray_volume_entry_point + i * path_step;
     
         <span class="keywordflow">if</span>( opacity &lt; 0.01 )
         {
             <span class="keywordflow">break</span>;
         }
     
         vec4 sample = getSampleAt( a )
                     + getSpecularAmount( a, ray_direction )
                     * vec4( 1, 1, 1, 0 );
     
         <span class="keywordtype">float</span> scaled_alpha = 1 - pow( 1 - sample.a, 256.0 / sample_count );
         result += sample.rgb * opacity * scaled_alpha;
         opacity *= 1 - scaled_alpha;
     }
</pre></div><p>With \(x_i\) as <code>x_i</code>. When \(a_i\) falls below a certain threshold, the computation is early finished. To make things simple, the ray direction is used as light direction for the specular lighting computation.</p>
<p>Finally, the resulted sum \( \vec v_\text{final color} \) is written to the framebuffer's color channels:</p>
<div class="fragment"><pre class="fragment">     gl_FragColor = vec4( result, 1.0 );
 }
</pre></div><dl class="author"><dt><b>Author:</b></dt><dd>Leonid Kostrykin </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>16.8.11 - 26.10.12 </dd></dl>

<p>Definition at line <a class="el" href="_direct_volume_rendering_8h_source.html#l00410">410</a> of file <a class="el" href="_direct_volume_rendering_8h_source.html">DirectVolumeRendering.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a81ba018cae27bd874db48d696426bf13"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::commitColorMap" ref="a81ba018cae27bd874db48d696426bf13" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Carna::VolumeRenderings::DVR::DirectVolumeRendering::commitColorMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Commits color map changes immediately. </p>
<p>As described <a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#DVR_ColorMap">here</a>, changes to the color map usually are not applied immediately. Use this method whenever you need to ensure that the renderer's state is up to date.</p>
<dl class="since"><dt><b>Since:</b></dt><dd><a class="el" href="_version_log.html#v_2_5">API Version 2.5</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a61c0d6e0a7346ab73d7012118d57fc88"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::getPositionedObject" ref="a61c0d6e0a7346ab73d7012118d57fc88" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_carna_1_1base_1_1model_1_1_object3_d.html">base::model::Object3D</a>&amp; Carna::VolumeRenderings::DVR::DirectVolumeRendering::getPositionedObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References the <a class="el" href="class_carna_1_1base_1_1model_1_1_object3_d.html">base::model::Object3D</a> to be re-positioned. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a4e45d81de275d63ce9932c1a26db5fe2" title="Tells whether an base::model::Object3D is selected to be re-positioned.">hasPositionedObject()</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="ad09b9fec2d6a7822e5047ee189a4bd55"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::removePositionedObject" ref="ad09b9fec2d6a7822e5047ee189a4bd55" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Carna::VolumeRenderings::DVR::DirectVolumeRendering::removePositionedObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets no <a class="el" href="class_carna_1_1base_1_1model_1_1_object3_d.html">base::model::Object3D</a> to be re-positioned. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><code>!hasPositionedObject()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="adaa690891bb681c6262ed7b039406d5d"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::renderDepth" ref="adaa690891bb681c6262ed7b039406d5d" args="(RayMarching &amp;) override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Carna::VolumeRenderings::DVR::DirectVolumeRendering::renderDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_carna_1_1_volume_renderings_1_1_ray_marching.html">RayMarching</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does nothing. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_carna_1_1_volume_renderings_1_1_volume_renderer_mode.html#a2878d62c57867c9483b65f03fa3339f6">VolumeRendererMode::renderDepth</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_carna_1_1_volume_renderings_1_1_volume_renderer_single_pass_mode.html#ad86b1935d142c35bb74282bfb988968a">Carna::VolumeRenderings::VolumeRendererSinglePassMode</a>.</p>

</div>
</div>
<a class="anchor" id="a534cae1c8abdc86b35302703d73ed8df"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::resizeBuffers" ref="a534cae1c8abdc86b35302703d73ed8df" args="(int width, int height) override" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Carna::VolumeRenderings::DVR::DirectVolumeRendering::resizeBuffers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [override, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Must be invoked when associated renderer is resized. The <a class="el" href="class_carna_1_1_volume_renderings_1_1_volume_renderer.html">VolumeRenderer</a> implementations does so. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd><code><a class="el" href="class_carna_1_1_volume_renderings_1_1_volume_renderer_mode.html#af0355e5378dae09371594f5b1fa1d87d" title="Tells whether prepareForRenderer already has been invoked.">isInitialized()</a></code></dd></dl>
<p>Shall be reimplemented when any buffers need to be resized. </p>

<p>Reimplemented from <a class="el" href="class_carna_1_1_volume_renderings_1_1_volume_renderer_mode.html#a555c93c1ec1ebcfa6d8ab21251140d6a">Carna::VolumeRenderings::VolumeRendererMode</a>.</p>

</div>
</div>
<a class="anchor" id="a7dd0ea594a93e5fca6acb0e270555aae"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::setLightAmplitude" ref="a7dd0ea594a93e5fca6acb0e270555aae" args="(double lightAmplitude)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Carna::VolumeRenderings::DVR::DirectVolumeRendering::setLightAmplitude </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lightAmplitude</em></td><td>)</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the currently configured light amplitude to <em>lightAmplitude</em>. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><code>base::isEqual( <a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#aad97cee41099ab8a096a78ca9e6cc2c7" title="Tells the currently configured light amplitude.">getLightAmplitude()</a>, lightAmplitude )</code> </dd></dl>

</div>
</div>
<a class="anchor" id="af8381000ba14daeb5113db60a517373a"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::setLightBackFaceAmount" ref="af8381000ba14daeb5113db60a517373a" args="(double lightBackFaceAmount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Carna::VolumeRenderings::DVR::DirectVolumeRendering::setLightBackFaceAmount </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lightBackFaceAmount</em></td><td>)</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the currently configured light amount multiplier for back faces. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><code>base::isEqual( <a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a5fecdf8805f843c997aace6a156ca4dd" title="Tells the currently configured light amount multiplier for back faces.">getLightBackFaceAmount()</a>, lightBackFaceAmount )</code> </dd></dl>

</div>
</div>
<a class="anchor" id="adf84e8707976744a151af909d1d9ff7b"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::setLightBias" ref="adf84e8707976744a151af909d1d9ff7b" args="(double lightBias)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Carna::VolumeRenderings::DVR::DirectVolumeRendering::setLightBias </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lightBias</em></td><td>)</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the currently configured light bias to <em>lightBias</em>. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><code>base::isEqual( <a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#aae18b9606d4a30e304478f1700907045" title="Tells the currently configured light bias.">getLightBias()</a>, lightBias )</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a0f37f1c99ee26e6d78eacad1ba49470e"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::setLighting" ref="a0f37f1c99ee26e6d78eacad1ba49470e" args="(bool lighting)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Carna::VolumeRenderings::DVR::DirectVolumeRendering::setLighting </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lighting</em></td><td>)</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether lighting is enabled. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><code><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a65e1c3dd682237b32e8cc95aaa7faf3e" title="Tells whether lighting is enabled.">hasLighting()</a> == lighting</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ac49011f4baa47626a50c01df26c0af4d"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::setPickingSaturation" ref="ac49011f4baa47626a50c01df26c0af4d" args="(double pickingSaturation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Carna::VolumeRenderings::DVR::DirectVolumeRendering::setPickingSaturation </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pickingSaturation</em></td><td>)</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the currently configured absorption threshold \(\theta \in [0,1]\) to light rays: when the ray intensity becomes <em>higher</em> than \(1 - \theta\), the ray is assumed to be absorbed completely. This is important for the 3D coordinates computation of clicked pixels in 2D space. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><code>base::isEqual( <a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#aec0ab43ad48e53cabd1250cfd3f9c2d2" title="Tells the currently configured absorption threshold  to light rays: when the ray intensity becomes hi...">getPickingSaturation()</a>, pickingSaturation )</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ab5554085f4113af1ccbe77c19be38031"></a><!-- doxytag: member="Carna::VolumeRenderings::DVR::DirectVolumeRendering::setPositionedObject" ref="ab5554085f4113af1ccbe77c19be38031" args="(Carna::base::model::Object3D &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Carna::VolumeRenderings::DVR::DirectVolumeRendering::setPositionedObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_carna_1_1base_1_1model_1_1_object3_d.html">Carna::base::model::Object3D</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td><code> [slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets <em>object</em> to be re-positioned. </p>
<dl class="post"><dt><b>Postcondition:</b></dt><dd><code><a class="el" href="class_carna_1_1_volume_renderings_1_1_d_v_r_1_1_direct_volume_rendering.html#a4e45d81de275d63ce9932c1a26db5fe2" title="Tells whether an base::model::Object3D is selected to be re-positioned.">hasPositionedObject()</a> &amp;&amp; &amp;getPositionedObject == &amp;object</code> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/Carna/VolumeRenderings/DVR/<a class="el" href="_direct_volume_rendering_8h_source.html">DirectVolumeRendering.h</a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/>
    <address class="footer">
        <small>
			Written by <a href="http://evoid.de">Leonid Kostrykin</a> at the
            Chair of Medical Engineering (mediTEC),
            RWTH Aachen University <p>
            Documentation generated by <a href="http://www.doxygen.org/index.html"> Doxygen </a>
        </small>
    </address>

</body>
</html>
