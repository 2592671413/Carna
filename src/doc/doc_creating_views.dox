/** \page   CreatingViews   Creating your own visualizations?
  *
  * This page consists of two parts: The first part describes \ref VolumeFromCPU,
  * whereas the second one considers \ref VolumeFromGPU.
  *
  * \section VolumeFromCPU Volume Data Access from CPU
  *
  * The CT data is stored as a \f$ \mathbb Z_0^3 \to [-1024,3071] \f$ scalar field.
  * In order to operate on it, all you need is a reference to the appropriate
  * \ref Carna::base::model::Volume "Volume" object:
  *
  * \code
  * double computeMeanHuv( const Carna::base::model::Volume& volume )
  * {
  *     double result = 0;
  *
  *     const unsigned int voxels_count = volume.size.x
  *                                     * volume.size.y
  *                                     * volume.size.z;
  *
  *     for( unsigned int x = 0; x < volume.size.x; ++x )
  *     for( unsigned int y = 0; y < volume.size.y; ++y )
  *     for( unsigned int z = 0; z < volume.size.z; ++z )
  *     {
  *         const signed int huv = volume( x, y, z );
  *         result += huv / voxels_count;
  *     }
  *
  *     return result;
  * }
  * \endcode
  *
  * \section VolumeFromGPU Providing Volume Data to the GPU
  *
  * Start with this code if you do require the volume as a 3D texture.
  *
  * \c MyRenderer.h header:
  *
  * \code
  * #include <Carna/base/view/Renderer.h>
  * #include <Carna/base/Visualization.h>
  *
  * class MyRenderer : public Carna::base::view::Renderer
  * {
  *
  * public:
  *
  *     Renderer
  *         ( Carna::base::Visualization& module
  *         , Carna::base::view::SceneProvider& provider
  *         , QObject* parent = nullptr );
  *
  * protected:
  *
  *     virtual void renderColor() override;
  *
  *     virtual void renderDepth() override;
  *
  *     virtual void fetchSceneMatrix
  *         ( Carna::base::Transformation& sceneMatrix
  *         , const Carna::base::Transformation& cameraMatrix
  *         , const Carna::base::Transformation& projectionMatrix ) const override;
  *
  * }; // MyRenderer
  *
  * class MyVisualization : public Carna::base::Visualization
  * {
  *
  * protected:
  *
  *     virtual Carna::base::view::Renderer* createRenderer( Carna::base::view::SceneProvider& provider ) override;
  *
  * };
  * \endcode
  *
  * Implementation:
  *
  * \code
  * #include <GL/glew.h>
  * #include <Carna/base/view/SceneProvider.h>
  * #include "MyRenderer.h"
  *
  * MyRenderer::MyRenderer
  *     ( Carna::base::Visualization& module
  *     , Carna::base::view::SceneProvider& provider
  *     , QObject* parent )
  *
  *     : Carna::base::view::Renderer
  *         ( module
  *         , provider
  *         , parent )
  * {
  *
  *  // this is fairly optional
  *
  *     glDisable( GL_DEPTH_TEST );
  *     glBlendFunc( GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR );
  *
  *     glBindTexture( GL_TEXTURE_3D, volumeTextureID() );
  *
  * }
  *
  * void MyRenderer::fetchSceneMatrix
  *     ( Carna::base::Transformation& sceneMatrix
  *     , const Carna::base::Transformation& cameraMatrix
  *     , const Carna::base::Transformation& projectionMatrix ) const
  * {
  *     using Carna::Transformation;
  *
  *  // scene space
  *
  *     Carna::base::view::Renderer::fetchSceneMatrix( sceneMatrix, cameraMatrix, projectionMatrix );
  *
  *  // volume space
  *
  *     sceneMatrix = sceneMatrix * Carna::base::Transformation().translate( -0.5, -0.5, -0.5 );
  * }
  *
  * void MyRenderer::renderColor()
  * {
  *     glClear( GL_COLOR_BUFFER_BIT );
  *
  *     glEnable( GL_BLEND );
  *     glEnable( GL_TEXTURE_3D );
  *
  *     for( float z = 0.f; z <= 1.f; z += 0.1f )
  *     {
  *         glBegin( GL_TRIANGLE_FAN );
  *
  *         glTexCoord3f( 0, 0, z );
  *         glVertex3f( 0, 0, z );
  *
  *         glTexCoord3f( 0, 1, z );
  *         glVertex3f( 0, 1, z );
  *
  *         glTexCoord3f( 1, 1, z );
  *         glVertex3f( 1, 1, z );
  *
  *         glTexCoord3f( 1, 0, z );
  *         glVertex3f( 1, 0, z );
  *
  *         glEnd();
  *     }
  *
  *     glDisable( GL_BLEND );
  *     glDisable( GL_TEXTURE_3D );
  *
  *     this->paintObjects3D();
  * }
  *
  * void MyRenderer::renderDepth()
  * {
  * }
  *
  * Carna::base::view::Renderer* MyVisualization::createRenderer( Carna::base::view::SceneProvider& provider )
  * {
  *     return new MyRenderer( *this, provider );
  * }
  * \endcode
  *
  * This sample code draws 11 equidistant slices of the 3D volume data;
  * the result is illustrated below.
  *
  * \image html MyView01.png "result of the above sample code"
  */
