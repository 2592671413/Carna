/** \page   CoordinateSystems   Coordinate Systems
  *
  * \image html 3D-Transformation.png
  *
  * \section Coordinate Transformation in Detail
  *
  * \subsection VolumeSpace Volume Space
  *
  * The volume data is uploaded to video memory as a 3D texture. Texture coordinates
  * are conventionally specified as \f$ [ 0, 1 ]^n\f$. For \f$ n = 3 \f$, this is what
  * %Carna refers to as \b volume \b space or \b texture \b space coordinates, it's vector
  * components being the vertex' coordinates on the x-, y-, and z-axis of the 3D texture:
  *
  * \f[ v_\text{volumespace} = \begin{pmatrix}u\\s\\t\end{pmatrix} \quad \text{with} \quad u, s, t \in [0,1] \f]
  *
  * \subsection ModelSpace Model Space
  *
  * The \b model \b space or \b object \b space is based on a scaling of the volume space. It
  * is defined as
  *
  * \f[ v_\text{modelspace} =
  * \underbrace{\begin{pmatrix}
  * (\text{width} - 1) \cdot \Delta x & 0 & 0 & 0 \\
  * 0 & (\text{height} - 1) \cdot \Delta y & 0 & 0 \\
  * 0 & 0 & (\text{depth} - 1) \cdot \Delta z & 0 \\
  * 0 & 0 & 0 & 1
  * \end{pmatrix}}_{M_0} \cdot v_\text{volumespace} \f]
  *
  * with \f$\text{width}\f$, \f$\text{height}\f$, \f$\text{depth}\f$ being the number of
  * voxels along the texture's x-, y- and z-axis; and \f$\Delta x, \Delta y, \Delta z\f$
  * being the spacings between two neighboring voxels along the particular axis in
  * millimeters. Therefore, <b>model units</b> are also millimeters.
  *
  * The transformation between those two spaces is encapsulated by the
  * \ref Carna::base::Position "Position" class:
  * - \ref Carna::base::Position::toMillimetersTransformation "Position::toMillimetersTransformation"
  *   computes the \f$M_0\f$ matrix.
  * - \ref Carna::base::Position::toVolumeUnitsTransformation "Position::toVolumeUnitsTransformation"
  *   computes the \f$M_0^{-1}\f$ matrix.
  *
  * \subsection SceneSpace Scene Space
  *
  * The \b scene \b matrix \f$S\f$ maps from volume space into scene space:
  *
  * \f[ S = S_0 \cdot M_0 \f]
  *
  * At simplest -
  * and this is what applies for the \ref Carna::base::Renderer::fetchSceneMatrix "default implementation" -
  * the \b scene \b space equals the model space, implying \f$ S_0 \f$ being identity.
  * However, any particular implementation is free to use any different \f$ S_0 \f$ with
  *
  * \f[ S_0 = \begin{pmatrix}
  * r_{11} & r_{12} & r_{13} & t_x \\
  * r_{21} & r_{22} & r_{23} & t_y \\
  * r_{31} & r_{32} & r_{33} & t_z \\
  * 0 & 0 & 0 & 1
  * \end{pmatrix}
  * \text{ and }
  * \sqrt{r_{1j}^2 + r_{2j}^2 + r_{3j}^2} = 1
  * \text{ for }
  * j = 1, 2, 3\f]
  *
  * Hence, \b scene \b units - the units used to specify scene space coordinates - are millimeters too.
  *
  * \subsection CameraSpace Camera Space
  *
  * The <b>camera space</b> is also commonly refered to as <b>view space</b> and
  * <b>eye space</b>. The \ref Carna::base::Camera "camera implementation" is free to use any
  * <b>camera matrix</b> \f$C\f$. Relatively to the scene space, the camera space is defined as
  * follows:
  *
  * \f[ v_\text{cameraspace} = C \cdot v_\text{scenespace} \f]
  *
  * \subsection ScreenSpace Screen Space
  *
  * \note
  * The screen space in %Carna corresponds to what is called <b>clipping coordinate system</b> in
  * computer graphics traditionally. The different term in %Carna results from historical reasons.
  *
  * The \ref Carna::base::Camera "camera implementation" is free to use any projection matrix \f$P\f$.
  * The transformation is defined as:
  *
  * \f[ v_\text{screenspace} = P \cdot v_\text{cameraspace} \f]
  *
  * The full transformation of any drawn vertex is defined as:
  *
  * \f[
  * v_\text{screenspace} =
  * P \cdot C \cdot S \cdot v_\text{volumespace} =
  * P \cdot C \cdot S_0 \cdot M_0 \cdot v_\text{volumespace}
  * \f]
  *
  * In screenspace, each vertex \f$v_\text{screenspace}=\left( x_\text{C}, y_\text{C}, z_\text{C}, w_\text{C} \right)\f$
  * is within the view frustum if and only if:
  *
  * \f[
  * -w_\text{C} \leq x_\text{C} \leq w_\text{C} \wedge
  * -w_\text{C} \leq y_\text{C} \leq w_\text{C} \wedge
  * -w_\text{C} \leq z_\text{C} \leq w_\text{C}
  * \f]
  *
  * \subsection FixedOpenGLTransformations Fixed OpenGL Transformations
  *
  * The <b>screenspace</b> coordinates are then transformed into <b>normalized device coordinates</b>.
  *
  * This morphs the view frustum into a cuboid shape:
  *
  * \f[ v_\text{nd} = \left( x_\text{nd}, y_\text{nd}, z_\text{nd} \right) = \left( \frac{x_\text{C}}{w_\text{C}}, \frac{y_\text{C}}{w_\text{C}}, \frac{z_\text{C}}{w_\text{C}} \right) \f]
  *
  * Here, the visible space is identified by \f$[-1, +1]^2 \times [0, 1]\f$.
  * These coordinates are scaled to the <b>window coordinates</b>
  * \f$ v_\text{wnd} = \left( x_\text{wnd}, y_\text{wnd}, z_\text{wnd} \right) \subset \mathbb{N}^2 \times [0, 1] \f$
  * as a final step, corresponding to following rules:
  *
  * - \f$z_\text{wnd} = z_\text{nd}\f$
  * - \f$\left( -1, y_\text{nd}, z_\text{nd} \right)\f$ is mapped to the left-most pixel column \f$\left( 0, y_\text{wnd}, z_\text{wnd} \right)\f$.
  * - \f$\left( x_\text{nd}, -1, z_\text{nd} \right)\f$ is mapped to the top-most pixel row \f$\left( x_\text{wnd}, 0, z_\text{wnd} \right)\f$.
  */
